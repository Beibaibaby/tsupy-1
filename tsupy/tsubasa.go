/*
cgo stubs for package tsubasa.
File is generated by gopy. Do not edit.
gopy gen -output=tsupy -vm=python3 github.com/js061/tsubasa
*/

package main

/*

#cgo CFLAGS: -I/usr/local/opt/python@3.9/Frameworks/Python.framework/Versions/3.9/include/python3.9 -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: -L/usr/local/opt/python@3.9/Frameworks/Python.framework/Versions/3.9/lib -lpython3.9 -ldl   -framework CoreFoundation 

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"github.com/go-python/gopy/gopyh" // handler
	
	"github.com/js061/tsubasa"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {
	
}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {
	
}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}



// --- generated code for package: tsubasa below: ---


// ---- External Types Outside of Targeted Packages ---

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}


// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}


// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}


// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}


// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}


// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}


// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}


// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}


// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}


// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}


// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}


// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}


// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}


// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}


// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}


// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}


// ---- Package: tsubasa ---

// ---- Types ---

// Converters for pointer handles for type: *tsubasa.BasicWindowDFTResult
func ptrFromHandle_Ptr_tsubasa_BasicWindowDFTResult(h CGoHandle) *tsubasa.BasicWindowDFTResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tsubasa.BasicWindowDFTResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.BasicWindowDFTResult{})).(*tsubasa.BasicWindowDFTResult)
}
func handleFromPtr_Ptr_tsubasa_BasicWindowDFTResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tsubasa.BasicWindowDFTResult", p))
}

// Converters for pointer handles for type: *tsubasa.BasicWindowResult
func ptrFromHandle_Ptr_tsubasa_BasicWindowResult(h CGoHandle) *tsubasa.BasicWindowResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tsubasa.BasicWindowResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.BasicWindowResult{})).(*tsubasa.BasicWindowResult)
}
func handleFromPtr_Ptr_tsubasa_BasicWindowResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tsubasa.BasicWindowResult", p))
}

// Converters for pointer handles for type: *tsubasa.DataOfChannel
func ptrFromHandle_Ptr_tsubasa_DataOfChannel(h CGoHandle) *tsubasa.DataOfChannel {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tsubasa.DataOfChannel")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.DataOfChannel{})).(*tsubasa.DataOfChannel)
}
func handleFromPtr_Ptr_tsubasa_DataOfChannel(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tsubasa.DataOfChannel", p))
}

// Converters for pointer handles for type: *tsubasa.Pair
func ptrFromHandle_Ptr_tsubasa_Pair(h CGoHandle) *tsubasa.Pair {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tsubasa.Pair")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.Pair{})).(*tsubasa.Pair)
}
func handleFromPtr_Ptr_tsubasa_Pair(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tsubasa.Pair", p))
}

// Converters for pointer handles for type: *tsubasa.Point
func ptrFromHandle_Ptr_tsubasa_Point(h CGoHandle) *tsubasa.Point {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tsubasa.Point")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.Point{})).(*tsubasa.Point)
}
func handleFromPtr_Ptr_tsubasa_Point(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tsubasa.Point", p))
}

// Converters for pointer handles for type: *tsubasa.RowBWR
func ptrFromHandle_Ptr_tsubasa_RowBWR(h CGoHandle) *tsubasa.RowBWR {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tsubasa.RowBWR")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.RowBWR{})).(*tsubasa.RowBWR)
}
func handleFromPtr_Ptr_tsubasa_RowBWR(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tsubasa.RowBWR", p))
}

// Converters for pointer handles for type: *tsubasa.RowBWRDFT
func ptrFromHandle_Ptr_tsubasa_RowBWRDFT(h CGoHandle) *tsubasa.RowBWRDFT {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tsubasa.RowBWRDFT")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.RowBWRDFT{})).(*tsubasa.RowBWRDFT)
}
func handleFromPtr_Ptr_tsubasa_RowBWRDFT(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tsubasa.RowBWRDFT", p))
}

// Converters for pointer handles for type: *tsubasa.SerializedPair
func ptrFromHandle_Ptr_tsubasa_SerializedPair(h CGoHandle) *tsubasa.SerializedPair {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tsubasa.SerializedPair")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.SerializedPair{})).(*tsubasa.SerializedPair)
}
func handleFromPtr_Ptr_tsubasa_SerializedPair(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tsubasa.SerializedPair", p))
}

// Converters for pointer handles for type: *map[int][]tsubasa.Point
func ptrFromHandle_Ptr_Map_int_Slice_tsubasa_Point(h CGoHandle) *map[int][]tsubasa.Point {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*map[int][]tsubasa.Point")
	if p == nil {
		return nil
	}
	return p.(*map[int][]tsubasa.Point)
}
func handleFromPtr_Ptr_Map_int_Slice_tsubasa_Point(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*map[int][]tsubasa.Point", p))
}

// Converters for implicit pointer handles for type: []tsubasa.Point
func ptrFromHandle_Slice_tsubasa_Point(h CGoHandle) *[]tsubasa.Point {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]tsubasa.Point")
	if p == nil {
		return nil
	}
	return p.(*[]tsubasa.Point)
}
func deptrFromHandle_Slice_tsubasa_Point(h CGoHandle) []tsubasa.Point {
	p := ptrFromHandle_Slice_tsubasa_Point(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_tsubasa_Point(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]tsubasa.Point", p))
}

// --- wrapping slice: []tsubasa.Point ---
//export Slice_tsubasa_Point_CTor
func Slice_tsubasa_Point_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_tsubasa_Point(&[]tsubasa.Point{}))
}

//export Slice_tsubasa_Point_len
func Slice_tsubasa_Point_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_tsubasa_Point(handle))
}

//export Slice_tsubasa_Point_elem
func Slice_tsubasa_Point_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_tsubasa_Point(handle)
	return handleFromPtr_tsubasa_Point(&(s[_idx]))
}

//export Slice_tsubasa_Point_subslice
func Slice_tsubasa_Point_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_tsubasa_Point(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_tsubasa_Point(&ss))
}

//export Slice_tsubasa_Point_set
func Slice_tsubasa_Point_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_tsubasa_Point(handle)
	s[_idx] = *ptrFromHandle_tsubasa_Point(_vl)
}

//export Slice_tsubasa_Point_append
func Slice_tsubasa_Point_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_tsubasa_Point(handle)
	*s = append(*s, *ptrFromHandle_tsubasa_Point(_vl))
}


// Converters for non-pointer handles for type: tsubasa.BasicWindowDFTResult
func ptrFromHandle_tsubasa_BasicWindowDFTResult(h CGoHandle) *tsubasa.BasicWindowDFTResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tsubasa.BasicWindowDFTResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.BasicWindowDFTResult{})).(*tsubasa.BasicWindowDFTResult)
}
func handleFromPtr_tsubasa_BasicWindowDFTResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tsubasa.BasicWindowDFTResult", p))
}

// Converters for non-pointer handles for type: tsubasa.BasicWindowResult
func ptrFromHandle_tsubasa_BasicWindowResult(h CGoHandle) *tsubasa.BasicWindowResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tsubasa.BasicWindowResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.BasicWindowResult{})).(*tsubasa.BasicWindowResult)
}
func handleFromPtr_tsubasa_BasicWindowResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tsubasa.BasicWindowResult", p))
}

// Converters for non-pointer handles for type: tsubasa.DataOfChannel
func ptrFromHandle_tsubasa_DataOfChannel(h CGoHandle) *tsubasa.DataOfChannel {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tsubasa.DataOfChannel")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.DataOfChannel{})).(*tsubasa.DataOfChannel)
}
func handleFromPtr_tsubasa_DataOfChannel(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tsubasa.DataOfChannel", p))
}

// Converters for non-pointer handles for type: tsubasa.Pair
func ptrFromHandle_tsubasa_Pair(h CGoHandle) *tsubasa.Pair {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tsubasa.Pair")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.Pair{})).(*tsubasa.Pair)
}
func handleFromPtr_tsubasa_Pair(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tsubasa.Pair", p))
}

// Converters for non-pointer handles for type: tsubasa.Point
func ptrFromHandle_tsubasa_Point(h CGoHandle) *tsubasa.Point {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tsubasa.Point")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.Point{})).(*tsubasa.Point)
}
func handleFromPtr_tsubasa_Point(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tsubasa.Point", p))
}

// Converters for non-pointer handles for type: tsubasa.RowBWR
func ptrFromHandle_tsubasa_RowBWR(h CGoHandle) *tsubasa.RowBWR {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tsubasa.RowBWR")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.RowBWR{})).(*tsubasa.RowBWR)
}
func handleFromPtr_tsubasa_RowBWR(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tsubasa.RowBWR", p))
}

// Converters for non-pointer handles for type: tsubasa.RowBWRDFT
func ptrFromHandle_tsubasa_RowBWRDFT(h CGoHandle) *tsubasa.RowBWRDFT {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tsubasa.RowBWRDFT")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.RowBWRDFT{})).(*tsubasa.RowBWRDFT)
}
func handleFromPtr_tsubasa_RowBWRDFT(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tsubasa.RowBWRDFT", p))
}

// Converters for non-pointer handles for type: tsubasa.SerializedPair
func ptrFromHandle_tsubasa_SerializedPair(h CGoHandle) *tsubasa.SerializedPair {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tsubasa.SerializedPair")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tsubasa.SerializedPair{})).(*tsubasa.SerializedPair)
}
func handleFromPtr_tsubasa_SerializedPair(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tsubasa.SerializedPair", p))
}

// Converters for implicit pointer handles for type: map[int][]tsubasa.Point
func ptrFromHandle_Map_int_Slice_tsubasa_Point(h CGoHandle) *map[int][]tsubasa.Point {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[int][]tsubasa.Point")
	if p == nil {
		return nil
	}
	return p.(*map[int][]tsubasa.Point)
}
func deptrFromHandle_Map_int_Slice_tsubasa_Point(h CGoHandle) map[int][]tsubasa.Point {
	p := ptrFromHandle_Map_int_Slice_tsubasa_Point(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_int_Slice_tsubasa_Point(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[int][]tsubasa.Point", p))
}


// ---- Global Variables: can only use functions to access ---


// ---- Interfaces ---


// ---- Structs ---

// --- wrapping struct: tsubasa.DataOfChannel ---
//export tsubasa_DataOfChannel_CTor
func tsubasa_DataOfChannel_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_tsubasa_DataOfChannel(&tsubasa.DataOfChannel{}))
}

// --- wrapping struct: tsubasa.Pair ---
//export tsubasa_Pair_CTor
func tsubasa_Pair_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_tsubasa_Pair(&tsubasa.Pair{}))
}

// --- wrapping struct: tsubasa.Point ---
//export tsubasa_Point_CTor
func tsubasa_Point_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_tsubasa_Point(&tsubasa.Point{}))
}

// --- wrapping struct: tsubasa.RowBWR ---
//export tsubasa_RowBWR_CTor
func tsubasa_RowBWR_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_tsubasa_RowBWR(&tsubasa.RowBWR{}))
}

// --- wrapping struct: tsubasa.RowBWRDFT ---
//export tsubasa_RowBWRDFT_CTor
func tsubasa_RowBWRDFT_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_tsubasa_RowBWRDFT(&tsubasa.RowBWRDFT{}))
}

// --- wrapping struct: tsubasa.SerializedPair ---
//export tsubasa_SerializedPair_CTor
func tsubasa_SerializedPair_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_tsubasa_SerializedPair(&tsubasa.SerializedPair{}))
}

// --- wrapping struct: tsubasa.BasicWindowDFTResult ---
//export tsubasa_BasicWindowDFTResult_CTor
func tsubasa_BasicWindowDFTResult_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_tsubasa_BasicWindowDFTResult(&tsubasa.BasicWindowDFTResult{}))
}

// --- wrapping struct: tsubasa.BasicWindowResult ---
//export tsubasa_BasicWindowResult_CTor
func tsubasa_BasicWindowResult_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_tsubasa_BasicWindowResult(&tsubasa.BasicWindowResult{}))
}


// ---- Slices ---


// ---- Maps ---


// ---- Constructors ---


// ---- Functions ---

//export tsubasa_GetLocations
func tsubasa_GetLocations() CGoHandle {
	cret := tsubasa.GetLocations()
	
	return handleFromPtr_Slice_int(&cret)
}

//export tsubasa_GetMatrix
func tsubasa_GetMatrix() CGoHandle {
	cret := tsubasa.GetMatrix()
	
	return handleFromPtr_Slice_int(&cret)
}

//export tsubasa_GetRealMatrix
func tsubasa_GetRealMatrix() CGoHandle {
	cret := tsubasa.GetRealMatrix()
	
	return handleFromPtr_Slice_float64(&cret)
}

//export tsubasa_SetBasicWindowSize
func tsubasa_SetBasicWindowSize(size C.longlong, goRun C.char)  {
	if boolPyToGo(goRun) {
		go tsubasa.SetBasicWindowSize(int(size))
	} else {
		tsubasa.SetBasicWindowSize(int(size))
	}
}

//export tsubasa_GetLatitudes
func tsubasa_GetLatitudes() CGoHandle {
	cret := tsubasa.GetLatitudes()
	
	return handleFromPtr_Slice_float64(&cret)
}

//export tsubasa_GetLatitudesIdx
func tsubasa_GetLatitudesIdx() CGoHandle {
	cret := tsubasa.GetLatitudesIdx()
	
	return handleFromPtr_Slice_int(&cret)
}

//export tsubasa_ReadFileByLocation
func tsubasa_ReadFileByLocation(filename *C.char, locationRangeFile *C.char, goRun C.char)  {
	if boolPyToGo(goRun) {
		go tsubasa.ReadFileByLocation(C.GoString(filename), C.GoString(locationRangeFile))
	} else {
		tsubasa.ReadFileByLocation(C.GoString(filename), C.GoString(locationRangeFile))
	}
}

//export tsubasa_ReadFile
func tsubasa_ReadFile(filename *C.char, goRun C.char)  {
	if boolPyToGo(goRun) {
		go tsubasa.ReadFile(C.GoString(filename))
	} else {
		tsubasa.ReadFile(C.GoString(filename))
	}
}

//export tsubasa_ResetSketch
func tsubasa_ResetSketch(goRun C.char)  {
	if boolPyToGo(goRun) {
		go tsubasa.ResetSketch()
	} else {
		tsubasa.ResetSketch()
	}
}

//export tsubasa_Sketch
func tsubasa_Sketch() *C.char {
	return C.CString(tsubasa.Sketch())
	
}

//export tsubasa_AddDataFromFile
func tsubasa_AddDataFromFile(filename *C.char, locationRangeFile *C.char) *C.char {
	var __err error
	__err = tsubasa.AddDataFromFile(C.GoString(filename), C.GoString(locationRangeFile))
	
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export tsubasa_GetLongitudesIdx
func tsubasa_GetLongitudesIdx() CGoHandle {
	cret := tsubasa.GetLongitudesIdx()
	
	return handleFromPtr_Slice_int(&cret)
}

//export tsubasa_Init
func tsubasa_Init(goRun C.char)  {
	if boolPyToGo(goRun) {
		go tsubasa.Init()
	} else {
		tsubasa.Init()
	}
}

//export tsubasa_Query
func tsubasa_Query(thres C.double, queryStart C.longlong, queryEnd C.longlong) CGoHandle {
	cret := tsubasa.Query(float64(thres), int(queryStart), int(queryEnd))
	
	return handleFromPtr_Slice_int(&cret)
}

//export tsubasa_QueryInDB
func tsubasa_QueryInDB(thres C.double, start C.longlong, end C.longlong, granularity C.longlong) CGoHandle {
	cret := tsubasa.QueryInDB(float64(thres), int(start), int(end), int(granularity))
	
	return handleFromPtr_Slice_int(&cret)
}

//export tsubasa_SketchInDB
func tsubasa_SketchInDB(goRun C.char)  {
	if boolPyToGo(goRun) {
		go tsubasa.SketchInDB()
	} else {
		tsubasa.SketchInDB()
	}
}

//export tsubasa_Slide
func tsubasa_Slide(start C.longlong, cnt C.longlong, qsize C.longlong, bwsize C.longlong, offset C.longlong, rho C.double) CGoHandle {
	cret := tsubasa.Slide(int(start), int(cnt), int(qsize), int(bwsize), int(offset), float64(rho))
	
	return handleFromPtr_Slice_float64(&cret)
}

//export tsubasa_DeleteSkecth
func tsubasa_DeleteSkecth(isDFT C.char, goRun C.char)  {
	if boolPyToGo(goRun) {
		go tsubasa.DeleteSkecth(boolPyToGo(isDFT))
	} else {
		tsubasa.DeleteSkecth(boolPyToGo(isDFT))
	}
}

//export tsubasa_DirectCompute
func tsubasa_DirectCompute(thres C.double, start C.longlong, end C.longlong) CGoHandle {
	cret := tsubasa.DirectCompute(float64(thres), int(start), int(end))
	
	return handleFromPtr_Slice_int(&cret)
}

//export tsubasa_GetLongitudes
func tsubasa_GetLongitudes() CGoHandle {
	cret := tsubasa.GetLongitudes()
	
	return handleFromPtr_Slice_float64(&cret)
}

//export tsubasa_GetDataMapInfo
func tsubasa_GetDataMapInfo() C.longlong {
	return C.longlong(tsubasa.GetDataMapInfo())
	
}

//export tsubasa_GetNetworkUnweighted
func tsubasa_GetNetworkUnweighted(queryStart C.longlong, length C.longlong, thres C.double) CGoHandle {
	cret := tsubasa.GetNetworkUnweighted(int(queryStart), int(length), float64(thres))
	
	return handleFromPtr_Slice_int(&cret)
}

//export tsubasa_InitDB
func tsubasa_InitDB(username *C.char, password_ *C.char, goRun C.char)  {
	if boolPyToGo(goRun) {
		go tsubasa.InitDB(C.GoString(username), C.GoString(password_))
	} else {
		tsubasa.InitDB(C.GoString(username), C.GoString(password_))
	}
}

//export tsubasa_InitMatrix
func tsubasa_InitMatrix(goRun C.char)  {
	if boolPyToGo(goRun) {
		go tsubasa.InitMatrix()
	} else {
		tsubasa.InitMatrix()
	}
}

//export tsubasa_ReadFilesByLocation
func tsubasa_ReadFilesByLocation(dirname *C.char, locationRangeFile *C.char) *C.char {
	var __err error
	__err = tsubasa.ReadFilesByLocation(C.GoString(dirname), C.GoString(locationRangeFile))
	
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export tsubasa_CutDataMap
func tsubasa_CutDataMap(newDataMap CGoHandle, start C.longlong, end C.longlong, goRun C.char)  {
	if boolPyToGo(goRun) {
		go tsubasa.CutDataMap(ptrFromHandle_Ptr_Map_int_Slice_tsubasa_Point(newDataMap), int(start), int(end))
	} else {
		tsubasa.CutDataMap(ptrFromHandle_Ptr_Map_int_Slice_tsubasa_Point(newDataMap), int(start), int(end))
	}
}

//export tsubasa_GetCorrelationMatrix
func tsubasa_GetCorrelationMatrix(queryStart C.longlong, length C.longlong) CGoHandle {
	cret := tsubasa.GetCorrelationMatrix(int(queryStart), int(length))
	
	return handleFromPtr_Slice_float64(&cret)
}

//export tsubasa_GetTransitivity
func tsubasa_GetTransitivity(arr CGoHandle) C.double {
	return C.double(tsubasa.GetTransitivity(deptrFromHandle_Slice_float64(arr)))
	
}

//export tsubasa_GetTimeSeriesNum
func tsubasa_GetTimeSeriesNum() C.longlong {
	return C.longlong(tsubasa.GetTimeSeriesNum())
	
}

//export tsubasa_ReadFiles
func tsubasa_ReadFiles(dirname *C.char) *C.char {
	var __err error
	__err = tsubasa.ReadFiles(C.GoString(dirname))
	
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export tsubasa_ClearDataMap
func tsubasa_ClearDataMap(goRun C.char)  {
	if boolPyToGo(goRun) {
		go tsubasa.ClearDataMap()
	} else {
		tsubasa.ClearDataMap()
	}
}

//export tsubasa_GetBasicWindowSize
func tsubasa_GetBasicWindowSize() C.longlong {
	return C.longlong(tsubasa.GetBasicWindowSize())
	
}

//export tsubasa_GetNetworkWeightedRatio
func tsubasa_GetNetworkWeightedRatio(queryStart C.longlong, length C.longlong, rho C.double) CGoHandle {
	cret := tsubasa.GetNetworkWeightedRatio(int(queryStart), int(length), float64(rho))
	
	return handleFromPtr_Slice_float64(&cret)
}

//export tsubasa_GetNumberOfBW
func tsubasa_GetNumberOfBW(granularity C.longlong) C.longlong {
	return C.longlong(tsubasa.GetNumberOfBW(int(granularity)))
	
}

//export tsubasa_GetTimeSeriesLength
func tsubasa_GetTimeSeriesLength() C.longlong {
	return C.longlong(tsubasa.GetTimeSeriesLength())
	
}


